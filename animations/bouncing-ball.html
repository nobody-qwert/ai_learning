<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball in Triangle</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background: #000;
        }
        
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="info">
        <div>Bouncing Ball in Rotating Triangle</div>
        <div>Physics simulation with collision detection</div>
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Ball properties
        const ball = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 15,
            vx: 3,
            vy: 2,
            color: '#ff4444'
        };
        
        // Triangle properties
        const triangle = {
            centerX: canvas.width / 2,
            centerY: canvas.height / 2,
            size: 200,
            rotation: 0,
            rotationSpeed: 0.01
        };
        
        // Get triangle vertices based on rotation
        function getTriangleVertices() {
            const vertices = [];
            for (let i = 0; i < 3; i++) {
                const angle = triangle.rotation + (i * 2 * Math.PI / 3) - Math.PI / 2;
                vertices.push({
                    x: triangle.centerX + Math.cos(angle) * triangle.size,
                    y: triangle.centerY + Math.sin(angle) * triangle.size
                });
            }
            return vertices;
        }
        
        // Check if point is inside triangle
        function pointInTriangle(px, py, vertices) {
            const [v0, v1, v2] = vertices;
            
            function sign(p1, p2, p3) {
                return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
            }
            
            const d1 = sign({x: px, y: py}, v0, v1);
            const d2 = sign({x: px, y: py}, v1, v2);
            const d3 = sign({x: px, y: py}, v2, v0);
            
            const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
            const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
            
            return !(hasNeg && hasPos);
        }
        
        // Line intersection for collision detection
        function lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
            const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denom) < 1e-10) return null;
            
            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
            
            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                };
            }
            return null;
        }
        
        // Handle ball collision with triangle
        function handleCollision() {
            const vertices = getTriangleVertices();
            const nextX = ball.x + ball.vx;
            const nextY = ball.y + ball.vy;
            
            // Check each edge of the triangle
            for (let i = 0; i < 3; i++) {
                const v1 = vertices[i];
                const v2 = vertices[(i + 1) % 3];
                
                // Check if ball path intersects with triangle edge
                const intersection = lineIntersection(
                    ball.x, ball.y, nextX, nextY,
                    v1.x, v1.y, v2.x, v2.y
                );
                
                if (intersection) {
                    // Calculate edge normal
                    const edgeX = v2.x - v1.x;
                    const edgeY = v2.y - v1.y;
                    const edgeLength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);
                    const normalX = -edgeY / edgeLength;
                    const normalY = edgeX / edgeLength;
                    
                    // Reflect velocity
                    const dotProduct = ball.vx * normalX + ball.vy * normalY;
                    ball.vx -= 2 * dotProduct * normalX;
                    ball.vy -= 2 * dotProduct * normalY;
                    
                    // Move ball slightly away from edge
                    ball.x = intersection.x - normalX * ball.radius;
                    ball.y = intersection.y - normalY * ball.radius;
                    
                    return;
                }
            }
            
            // If no collision detected, check if ball is outside triangle
            if (!pointInTriangle(nextX, nextY, vertices)) {
                // Find closest edge and reflect
                let minDist = Infinity;
                let closestEdge = 0;
                
                for (let i = 0; i < 3; i++) {
                    const v1 = vertices[i];
                    const v2 = vertices[(i + 1) % 3];
                    
                    // Distance from point to line
                    const A = nextY - v1.y;
                    const B = v1.x - nextX;
                    const C = nextX * v1.y - v1.x * nextY;
                    const dist = Math.abs(A * v2.x + B * v2.y + C) / Math.sqrt(A * A + B * B);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        closestEdge = i;
                    }
                }
                
                // Reflect off closest edge
                const v1 = vertices[closestEdge];
                const v2 = vertices[(closestEdge + 1) % 3];
                const edgeX = v2.x - v1.x;
                const edgeY = v2.y - v1.y;
                const edgeLength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);
                const normalX = -edgeY / edgeLength;
                const normalY = edgeX / edgeLength;
                
                const dotProduct = ball.vx * normalX + ball.vy * normalY;
                ball.vx -= 2 * dotProduct * normalX;
                ball.vy -= 2 * dotProduct * normalY;
            }
        }
        
        function update() {
            // Update triangle rotation
            triangle.rotation += triangle.rotationSpeed;
            
            // Handle collision before moving
            handleCollision();
            
            // Update ball position
            ball.x += ball.vx;
            ball.y += ball.vy;
            
            // Ensure ball stays within triangle bounds
            const vertices = getTriangleVertices();
            if (!pointInTriangle(ball.x, ball.y, vertices)) {
                // Move ball back inside
                ball.x = triangle.centerX;
                ball.y = triangle.centerY;
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw triangle
            const vertices = getTriangleVertices();
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw ball
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Start the animation
        gameLoop();
    </script>
</body>
</html>
